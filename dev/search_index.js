var documenterSearchIndex = {"docs":
[{"location":"#PortHamiltonianSystems","page":"Home","title":"PortHamiltonianSystems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PortHamiltonianSystems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for port-Hamiltonian Systems in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The considered systems are of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"    Sigmaquadleftquadbeginaligned\n        dotx(t) = (J - R)Qx(t) + (G - P)u(t) \n        y(t) = (G + P)^top Qx(t) + (S - N)u(t)\n    endalignedright","category":"page"},{"location":"","page":"Home","title":"Home","text":"where J=-J^topin mathbbR^ntimes n is skew-symmetric, Rin mathbbR^ntimes n is positive semi-definite, Qin mathbbR^ntimes n is positive definite, Gin mathbbR^ntimes m, Pin mathbbR^ntimes m, Sin mathbbR^mtimes m and Nin mathbbR^mtimes m.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra, ControlSystemsBase\nusing PortHamiltonianSystems\n\nJ = [0 -1; 1 0]\nR = [1 -1; -1 2]\nQ = I(2)\nG = [1; 0;;]\n\nΣph = phss(J, R, Q, G)\n# This generates the system:\n# PortHamiltonianStateSpace{Float64}\n# J = \n#   0.0  -1.0\n#  1.0  0.0\n# R = \n#   1.0  -1.0\n#  -1.0   2.0\n# Q = \n#  1.0  0.0\n#  0.0  1.0\n# G = \n#  1.0\n#  0.0\n# P = \n#  0.0\n#  0.0\n# S = \n#  0.0\n# N = \n#  0.0\n\n# Compute the observability Gramian\ngram(Σph, :o)\n# 2×2 Matrix{Float64}:\n#  0.5  0.0\n#  0.0  0.0\n\n# Compute a numerically minimal realization\nΣphr = phminreal(Σph)\n\n# Compute H2 and Hinf errors\nnorm(Σph - Σphr) # 9.56908750203461e-17\nnorm(Σph - Σphr, Inf) # 1.8182097724708874e-16\n\n# Computes unstructured state-space realization\nΣ = ss(Σph)\n\n# Checking passivity\nispassive(Σ) # true\n\n# Computes pH realization for a given posdef X satisfying the KYP inequality \nX = kyp(Σ)\nΣph2 = phss(Σ, X)\n\nnorm(Σph - Σph2) # 1.3470909371896273e-16","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"T. Breiten, R. Morandin and P. Schulze. Error Bounds for Port-Hamiltonian Model and Controller Reduction Based on System Balancing. Computers & Mathematics with Applications 116, 100–115 (2022).\n\n\n\n","category":"page"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#PortHamiltonianSystems.PortHamiltonianStateSpace","page":"API","title":"PortHamiltonianSystems.PortHamiltonianStateSpace","text":"PortHamiltonianStateSpace{T}\n\nAn object representing a port-Hamiltonian state-space system.\n\ndx(t)/dt = (J-R)Qx(t) + (G-P)u(t)\ny(t)     = (G+P)'Qx(t) + (S-N)u(t)\n\nSee the function phss for a user facing constructor.\n\nFields:\n\nJ::SkewHermitian{T}\nR::Hermitian{T}\nQ::Hermitian{T}\nG::Matrix{T}\nP::Matrix{T}\nS::Hermitian{T}\nN::SkewHermitian{T}\n\n\n\n\n\n","category":"type"},{"location":"API/#ControlSystemsBase.gram-Tuple{PortHamiltonianStateSpace, Symbol}","page":"API","title":"ControlSystemsBase.gram","text":"X = gram(Σph, opt; kwargs...)\n\nReturns the Gramian of the system Σph. If opt is :c or :o  it returns the controllability or observability Gramian, respectively by calling the  gram from ControlSystems package.  If opt is :prc or :pro it returns the  positive-real controllability or observability Gramian, respectively (see prgram).\n\n\n\n\n\n","category":"method"},{"location":"API/#ControlSystemsBase.grampd-Tuple{PortHamiltonianStateSpace, Symbol}","page":"API","title":"ControlSystemsBase.grampd","text":"L = grampd(Σph, opt; kwargs...)\n\nReturns a Cholesky factor L of the Gramian of the system Σph. If opt is :c or :o  it returns the controllability or observability Gramian, respectively by calling the  grampd from ControlSystems.jl package.  If opt is :prc or :pro it returns a Cholesky factor L of the  positive-real controllability or observability Gramian, respectively.\n\n\n\n\n\n","category":"method"},{"location":"API/#ControlSystemsBase.ss-NTuple{7, Any}","page":"API","title":"ControlSystemsBase.ss","text":"Σ = ss(J, R, Q, G, P, S, N)\nΣ = ss(Σph)\n\nConverts a PortHamiltonianStateSpace to a standard StateSpace.\n\n\n\n\n\n","category":"method"},{"location":"API/#LinearAlgebra.norm","page":"API","title":"LinearAlgebra.norm","text":"norm(Σph, p=2; kwargs...)\n\nConverts a PortHamiltonianStateSpace to a StateSpace and calls norm on it. For more details see ControlSystems.jl package.\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianSystems.compose-NTuple{7, Any}","page":"API","title":"PortHamiltonianSystems.compose","text":"A, B, C, D = compose(J, R, Q, G, P, S, N)\n\nComposes the port-Hamiltonian matrices to standard state-space matrices according to\n\nA = (J - R) * Q\nB = G - P\nC = (G + P)' * Q\nD = S - N.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.decompose-Tuple{Matrix, Matrix, Matrix, Matrix, LinearAlgebra.Hermitian}","page":"API","title":"PortHamiltonianSystems.decompose","text":"J, R, Q, G, P, S, N = decompose(A, B, C, D, X)\n\nDecomposes the standard state-space matrices to port-Hamiltonian matrices for a given Hamiltonian X  according to\n\nQ = X\nJ = skew(A / X)\nR = -sym(A / X)\nG = 0.5 * (X \\ C' + B)\nP = 0.5 * (X \\ C' - B)\nS = sym(D)\nN = skew(D).\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.ispassive-Tuple{ControlSystemsBase.StateSpace}","page":"API","title":"PortHamiltonianSystems.ispassive","text":"ispassive(Σ::StateSpace; opt=:lmi, kwargs...)\nispassive(Σ::PortHamiltonianStateSpace; kwargs...)\n\nChecks whether the system Σ is passive by solving the KYP inequality using kyp (if opt=:lmi)  or checking the Popov function for passivity violations via sampopov (if opt=:popov). \n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.ispsd-Tuple{Any}","page":"API","title":"PortHamiltonianSystems.ispsd","text":"ispsd(M)\n\nReturns true if M is positive semi-definite, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.kyp-Tuple{ControlSystemsBase.StateSpace}","page":"API","title":"PortHamiltonianSystems.kyp","text":"X = kyp(Σ; kwargs...)\n\nTries to solve the KYP inequality via semi definite programming.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.kypmat-Tuple{ControlSystemsBase.StateSpace, Any}","page":"API","title":"PortHamiltonianSystems.kypmat","text":"W = kypmat(Σ, X)\n\nReturns the KYP matrix of the system Σ for a given matrix X.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.kypmax-Tuple{Any}","page":"API","title":"PortHamiltonianSystems.kypmax","text":"Xmin = kypmax(Σ; kwargs...)\n\nReturns the maximal solution to the KYP inequality by solving the ARE equation for the anti-stabilizing solution.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.kypmin-Tuple{Any}","page":"API","title":"PortHamiltonianSystems.kypmin","text":"Xmin = kypmin(Σ; kwargs...)\n\nReturns the minimal solution to the KYP inequality by solving the ARE for the stabilizing solution.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.lrcholesky-Tuple{Matrix}","page":"API","title":"PortHamiltonianSystems.lrcholesky","text":"L = lrcholesky(X; trunc_tol=1e-12)\n\nComputes a low-rank approximate Cholesky-like factorization of a symmetric positive semi-definite matrix X s.t. X = L * L (up to a prescribed tolerance trunc_tol).\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.phminreal-Tuple{PortHamiltonianStateSpace}","page":"API","title":"PortHamiltonianSystems.phminreal","text":"phminreal(Σph::PortHamiltonianStateSpace; trunc_tol=1e-12)\n\nComputes a structure preserving minimal realization of a port-Hamiltonian system [1].\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.phss-Tuple","page":"API","title":"PortHamiltonianSystems.phss","text":"Σph = phss(J, R, Q, G, P, S, N)\nΣph = phss(J, R, Q, G)\nΣph = phss(Γ, W, Q)\n\nCreates a port-Hamiltonian state-space model Σph::PortHamiltonianStateSpace{T} with matrix element type T.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.phss-Tuple{ControlSystemsBase.StateSpace}","page":"API","title":"PortHamiltonianSystems.phss","text":"Σph = phss(Σ)\nΣph = phss(Σ, X)\n\nConverts a passive StateSpace to a PortHamiltonianStateSpace by executing decompose. If X is not provided, the minimal solution of the KYP inequality is used, which is obtained by solving the ARE.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.popov-Tuple{ControlSystemsBase.StateSpace, Complex}","page":"API","title":"PortHamiltonianSystems.popov","text":"popov(Σ, s)\npopov(Σ, ω)\n\nEvaluates the popov function of the system Σ at the complex variable s.\n\nΦ(s) = Σ(s) + Σ(-s)'\n\nwhere Σ(s) is the frequency response (transfer function) of Σ at the complex variable s.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.prare-Tuple{ControlSystemsBase.StateSpace, Symbol, Any}","page":"API","title":"PortHamiltonianSystems.prare","text":"prare(Σ, opt, X; kwargs...)\n\nEvaluates the positive-real algebraic Riccati equation for system Σ and candidat solution X.\n\nIf opt is :o the positive-real controllability algebraic Riccati equation is evaluated,\n\nA'X + XA + (C' - XB) inv(D + D') (C - B'X).\n\nIf opt is :c the positive-real observability algebraic Riccati equation is evaluated,\n\nAX + XA' + (B - XC') inv(D + D') (B' - CX).\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.prgram-Tuple{ControlSystemsBase.StateSpace, Symbol}","page":"API","title":"PortHamiltonianSystems.prgram","text":"X = prgram(Σ, opt; kwargs...)\n\nReturns the positive-real Gramian of system Σ. If opt is :c or :o  it returns the positive-real controllability or positive-real observability Gramian, respectively, by solving the corresponding positive-real algebraic Riccati equation (see prare).\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.prgrampd-Tuple{ControlSystemsBase.StateSpace, Symbol}","page":"API","title":"PortHamiltonianSystems.prgrampd","text":"L = prgrampd(Σ, opt; kwargs...)\n\nReturns the Cholesky factor of the positive-real Gramian of system Σ (see prgram). If opt is :c or :o  it returns the positive-real controllability or positive-real observability Gramian, respectively.\n\nIn the case that the solution of the positive-real algebraic Riccati equation is not positive definite (due to numerical errors),  it is projected to the set of positive semi-definite matrices calling project_psd.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.project_psd-Tuple{Any}","page":"API","title":"PortHamiltonianSystems.project_psd","text":"Mpsd = project_psd(M; eigtol=1e-8)\n\nReturns the nearest positive semi-definite matrix to M by setting negative eigenvalues to eigtol.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.sampopov-Tuple{Any}","page":"API","title":"PortHamiltonianSystems.sampopov","text":"sampopov(Σ; ω=10 .^ range(-15, stop=5, length=5000))\n\nSamples the Popov function for the system Σ at ranges of frequencies ω.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.truncation-Tuple{Any, Any}","page":"API","title":"PortHamiltonianSystems.truncation","text":"truncation(d, L, trunc_tol) -> (dr, Lr)\n\nComputes a rank revealing factorization for a given LDL-decomposition of S = L * mathrmdiag(d) * L^T (up to a prescribed tolerance trunc_tol) such that L_r * diag(d_r) * L_r^T approx S.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.tsvd-Tuple{AbstractMatrix}","page":"API","title":"PortHamiltonianSystems.tsvd","text":"F = tsvd(A; kwargs...)\nReturns the truncated singular value decomposition of `A` by truncating small singular values below `ε`.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.unvec-Tuple{Vector}","page":"API","title":"PortHamiltonianSystems.unvec","text":"M = unvec(v)\n\nReturns the matrix M from the vectorized v, i.e., the inverse of LinearAlgebra.vec.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianSystems.unvech-Tuple{Vector}","page":"API","title":"PortHamiltonianSystems.unvech","text":"M = unvech(v)\n\nReturns the Hermitian matrix M from the half-vectorized v, i.e., the inverse of VectorizationTransforms.vech.\n\n\n\n\n\n","category":"method"}]
}
